---
title: Cipher 3
date: 2023-03-20 23:17:48
tags: cipher
mathjax: true
---

### 对称密码

一串比特序列 A（0 1 0 1 1 1 0 1）和另一串比特序列 B（1 1 0 0 0 1 0 1）经过两次 xor 操作后会有 $ A \bigoplus B \bigoplus B = A$

$$
0 1 0 1 1 1 0 1 \bigoplus 1 1 0 0 0 1 0 1 = 1 0 0 1 1 0 0 0
$$

$$
1 0 0 1 1 0 0 0 \bigoplus 1 1 0 0 0 1 0 1 = 0 1 0 1 1 1 0 1
$$

所以使用 xor 操作当作加加密算法，一串比特序列 B 当做密钥，就可以实现一个密码。

<!--more-->

### 一次性密码

使用 xor 操作每一次随机生成一串比特序列用于加密和解密，就构成了一次性密码。如果需要加密 “midnight” 这个字符串，就需要把这个字符串转换成 0 1 序列，然后再用等长的随机 0 1 序列对其进行 xor 加密。

这里存在几个问题

- 如果需要加密的字符串很长，那么它的 0 1 字符串就更长了，对应的随机 0 1 字符串也非常长
- 要解密加密后的 0 1 字符串，必须把密钥也传递给接收者，那么如果传递密钥的过程是不可破解的，那么就不需要加密，直接传递原始字符串即可
- 密钥的如何安全保存也是个问题

### DES

DES 是将 64 比特的明文加密成 64 比特的密文的对称密码算法。DES 是以 64 比特长度的明文作为一个单位进行加密的，这 64 位叫做一个分组。以分组位单位进行处理的密码算法也叫做分组密码。

DES 加密过程：

1. 将 64 比特的输入数据从中间分开，左边长度 32 比特，右边长度 32 比特
2. 将右侧的 32 比特直接输出
3. 将右侧的 32 比特发送到轮函数
4. 轮函数接收子密钥和 32 比特的右侧字符串的输入，得到一串随机的比特序列
5. 将步骤 4 产出的比特序列与左侧的 32 比特的字符串做 xor 运算，将结果输出

6. 将左右两组 32 比特交换后输入到下一轮

通过反复上面 1 - 5 的过程，构成 Feistel 网络。如图所示

![](https://github.com/hailingu/hailingu.github.io/raw/master/images/feistel-cipher-diagram.png?raw=true)

函数 F 即为轮函数。$K_i$ 为每一轮的子密钥。以第一轮为例

1. 明文被分成左边 32 比特（$L_0$）右边 32 比特 ($R_0$)
2. $R_0$ 直接输出得到 $R_1$
3. 轮函数 $F(K_0, R_0)$ 后得到随机比特序列，记为 $U_0$
4. 计算 $L_1 = L_0 \bigoplus U_0$
5. 交换 $L_1$ 和 $R_1$ 作为下一轮的输入

解密的过程，以最后一轮为例

1. 计算 $U_{n+1}=F(K_{n+1}, R_{n+1})$
2. 计算 $L_n = L_{n+1} \bigoplus U_{n+1}$
3. 交换 $L_n$ 和 $R_n$ 作为下一轮输入

想要破解 DES 密码方法有

- 差分分析，即改变一部分明文并分析密文如何随之改变
- 线性分析，明文和密文如果做 xor 操作，那么明文和密文结果为 0 的概率应该为 1/2。如果有大量的偏离 1/2 的明文和密文，可以通过分析得出破解密码的线索

### 三重 DES

IBM 弄了一个三重 DES，按以下顺序执行后得到输出结果，如果步骤 1 2 3 中的密钥一样，那么就是前面的普通 DES

1. DES 加密
2. DES 解密
3. DES 加密

解密的过程正好相反

1. DES 解密
2. DES 加密
3. DES 解密

其实 DES 的加密和解密过程是完全对称的，加密就是解密，解密也是加密，这也是 DES 的精妙之处。

### AES

AES 也是一种分组加密密码，密钥长度有 128，160， 192， 224， 256 这几个选项。标准 AES 的分组长度为 128，迷药长度可以选择 128， 192， 256 这 3 个选项

加密过程

1. 先将 0 到 255 中的 256 个整数打乱，生成一张替换表 S-Box
2. 对于待加密的信息的每一个字节，查找其表示的数字在 S-Box 里面对应的值。例如待加密的消息为 “abc”，那么对于字符 “a”，其对应的数字为 97，然后找到 97 在 S-Box 里的值，比如说为 42，那么就将 "a" 替换成 "\*"；字符“bc”的做法同“a”
3. 将步骤 2 中得到的信息，以 4 个字节为一组做
   ShiftRows 操作。例如加密后的字符串为 "abcd1234"，这里就分成 2 组："abcd"，“1234”。经过 ShiftRows 操作后 "abcd" -> "bcda"，"1234" -> "3412"
4. 将步骤 3 中得到的结果，组成一个 $4 \times n$ 的矩阵，步骤 3 中得到的字符串长度如果为 $l$，那么 $n = \lceil l / 4 \rceil$。将得到的这个矩阵 $M$， 乘以另一个矩阵 $T(n,n)$，得到这一步的输出 $R=M \cdot T$
5. 将步骤 4 中的 $R$ 矩阵与密钥进行 xor 操作得到最后的输出。
6. 重复 1 - 5 步骤 10 到 14 轮。

可以发现 AES 的过程通过每一个步骤逆运算就可以解密了。

### 加密算法的选择

1. 不选 DES
2. 不选三重 DES
3. 选 AES

### 练习测试

1. 相当于 +3 后再取模

2. 个人认为 Alice 是对的，不同意书上的解答。

3. 当前设定下，20 年的时间能遍历的密钥空间

$$ 10^{20} \times 10^{100} \times 10^{20} \times 365 \times 24 \times 3600 < 10^{140} \times 365 \times 24 \times 3600 $$

其中

$$365 < 400 = 4 \times 10^2$$

$$24 < 4 \times 10 $$

$$3600 < 4 \times 10^3 $$

就有

$$ 10^{20} \times 10^{100} \times 10^{20} \times 365 \times 24 \times 3600 < 10^{140} \times 4^3 \times 10^6 $$

$$ 10^{140} \times 4^3 \times 10^6 = 10^{146} \times 4^3 < (2^{3.3})^{146}\times 2 ^ 6 < 2^{482 + 6} = 2^{488}$$

故 512 比特足够用了

4. o x x x o o
