---
title: Cipher 3
date: 2023-03-20 23:17:48
tags: cipher
mathjax: true
---

### 对称密码

一串比特序列 A（0 1 0 1 1 1 0 1）和另一串比特序列 B（1 1 0 0 0 1 0 1）经过两次 xor 操作后会有 $ A \bigoplus B \bigoplus B = A$

$$
0 1 0 1 1 1 0 1 \bigoplus 1 1 0 0 0 1 0 1 = 1 0 0 1 1 0 0 0
$$

$$
1 0 0 1 1 0 0 0 \bigoplus 1 1 0 0 0 1 0 1 = 0 1 0 1 1 1 0 1
$$

所以使用 xor 操作当作加加密算法，一串比特序列 B 当做密钥，就可以实现一个密码。

### 一次性密码

使用 xor 操作每一次随机生成一串比特序列用于加密和解密，就构成了一次性密码。如果需要加密 “midnight” 这个字符串，就需要把这个字符串转换成 0 1 序列，然后再用等长的随机 0 1 序列对其进行 xor 加密。

这里存在几个问题

- 如果需要加密的字符串很长，那么它的 0 1 字符串就更长了，对应的随机 0 1 字符串也非常长
- 要解密加密后的 0 1 字符串，必须把密钥也传递给接收者，那么如果传递密钥的过程是不可破解的，那么就不需要加密，直接传递原始字符串即可
- 密钥的如何安全保存也是个问题

### DES

DES 是将 64 比特的明文加密成 64 比特的密文的对称密码算法。DES 是以 64 比特长度的明文作为一个单位进行加密的，这 64 位叫做一个分组。以分组位单位进行处理的密码算法也叫做分组密码。

DES 加密过程：

1. 将 64 比特的输入数据从中间分开，左边长度 32 比特，右边长度 32 比特
2. 将右侧的 32 比特直接输出
3. 将右侧的 32 比特发送到轮函数
4. 轮函数接收子密钥和 32 比特的右侧字符串的输入，得到一串随机的比特序列
5. 将步骤 4 产出的比特序列与左侧的 32 比特的字符串做 xor 运算，将结果输出

6. 将左右两组 32 比特交换后输入到下一轮

通过反复上面 1 - 5 的过程，构成 Feistel 网络，即可进行对字符串的加密。解密的过程就是将 5 到 1 执行一遍，即可。

想要破解 DES 密码方法有

- 差分分析，即改变一部分明文并分析密文如何随之改变
- 线性分析，明文和密文如果做 xor 操作，那么明文和密文结果为 0 的概率应该为 1/2。如果有大量的偏离 1/2 的明文和密文，可以通过分析得出破解密码的线索

### 练习测试

1. 相当于 +3 后再取模

2. 个人认为 Alice 是对的，不同意书上的解答。
