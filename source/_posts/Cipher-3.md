---
title: Cipher 3
date: 2023-03-20 23:17:48
tags: cipher
mathjax: true
---

### 对称密码

一串比特序列 A（0 1 0 1 1 1 0 1）和另一串比特序列 B（1 1 0 0 0 1 0 1）经过两次 xor 操作后会有 $ A \bigoplus B \bigoplus B = A$

$$
0 1 0 1 1 1 0 1 \bigoplus 1 1 0 0 0 1 0 1 = 1 0 0 1 1 0 0 0
$$

$$
1 0 0 1 1 0 0 0 \bigoplus 1 1 0 0 0 1 0 1 = 0 1 0 1 1 1 0 1
$$

所以使用 xor 操作当作加加密算法，一串比特序列 B 当做密钥，就可以实现一个密码。

<!--more-->

### 一次性密码

使用 xor 操作每一次随机生成一串比特序列用于加密和解密，就构成了一次性密码。如果需要加密 “midnight” 这个字符串，就需要把这个字符串转换成 0 1 序列，然后再用等长的随机 0 1 序列对其进行 xor 加密。

这里存在几个问题

- 如果需要加密的字符串很长，那么它的 0 1 字符串就更长了，对应的随机 0 1 字符串也非常长
- 要解密加密后的 0 1 字符串，必须把密钥也传递给接收者，那么如果传递密钥的过程是不可破解的，那么就不需要加密，直接传递原始字符串即可
- 密钥的如何安全保存也是个问题

### DES

DES 是将 64 比特的明文加密成 64 比特的密文的对称密码算法。DES 是以 64 比特长度的明文作为一个单位进行加密的，这 64 位叫做一个分组。以分组位单位进行处理的密码算法也叫做分组密码。

DES 加密过程：

1. 将 64 比特的输入数据从中间分开，左边长度 32 比特，右边长度 32 比特
2. 将右侧的 32 比特直接输出
3. 将右侧的 32 比特发送到轮函数
4. 轮函数接收子密钥和 32 比特的右侧字符串的输入，得到一串随机的比特序列
5. 将步骤 4 产出的比特序列与左侧的 32 比特的字符串做 xor 运算，将结果输出

6. 将左右两组 32 比特交换后输入到下一轮

通过反复上面 1 - 5 的过程，构成 Feistel 网络。如图所示

![](https://github.com/hailingu/hailingu.github.io/raw/master/images/feistel-cipher-diagram.png?raw=true)

函数 F 即为轮函数。$K_i$ 为每一轮的子密钥。以第一轮为例

1. 明文被分成左边 32 比特（$L_0$）右边 32 比特 ($R_0$)
2. $R_0$ 直接输出得到 $R_1$
3. 轮函数 $F(K_0, R_0)$ 后得到随机比特序列，记为 $U_0$
4. 计算 $L_1 = L_0 \bigoplus U_0$
5. 交换 $L_1$ 和 $R_1$ 作为下一轮的输入

解密的过程，以最后一轮为例

1. 计算 $U_{n+1}=F(K_{n+1}, R_{n+1})$
2. 计算 $L_n = L_{n+1} \bigoplus U_{n+1}$
3. 交换 $L_n$ 和 $R_n$ 作为下一轮输入

想要破解 DES 密码方法有

- 差分分析，即改变一部分明文并分析密文如何随之改变
- 线性分析，明文和密文如果做 xor 操作，那么明文和密文结果为 0 的概率应该为 1/2。如果有大量的偏离 1/2 的明文和密文，可以通过分析得出破解密码的线索

### 三重 DES

IBM 弄了一个三重 DES，按以下顺序执行后得到输出结果，如果步骤 1 2 3 中的密钥一样，那么就是前面的普通 DES

1. DES 加密
2. DES 解密
3. DES 加密

解密的过程正好相反

1. DES 解密
2. DES 加密
3. DES 解密

其实 DES 的加密和解密过程是完全对称的，加密就是解密，解密也是加密，这也是 DES 的精妙之处。

### 练习测试

1. 相当于 +3 后再取模

2. 个人认为 Alice 是对的，不同意书上的解答。
